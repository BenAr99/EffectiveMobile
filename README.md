Для запуска: 
1) json-server --watch db.json --port 3000
2) ng serve --configuration production
3) npx serve ./dist/effective-mobile/browser -l 4200 -s  (Оптимизированная сборка)

Сценарий ошибок: 
1) При открытии диалогового окна фильма "Начало"
2) При отсутствии запущенного json-server

Ответы на вопросы: 
1) Процесс распространения событий Event Propagation в JavaScript делится на три фазы. **Первая** - ***Capturing*** - начинает свой путь с самого верхнего уровня и движется до элемента, с которым взаимодействовал пользователь. ***Target*** - вторая фаза, при котором процесс достиг цели. Здесь выполняются обработчики назначенные на элемент. ***Bubbling*** - третья и последняя фаза, когда процесс обратно возвращается к высшему уровню документа, оповещая родительские элементы и запуская обработчики наложенные на них. 2) Существует несколько способов применения знаний о фазах. Например, вместо того, чтобы навешивать обработчик на каждый дочерний элемент в списке, можно наложить его на родительский и отследить событие на нужном дочернем элементе. Так же можно перехватывать событие до того, как оно достигнет элемента или остановить дальнейшее выполнение механизма через **stopPropagation**.
2) ***Promise*** - это объект, представляющий однократный результат асинхронной операции. У него есть 3 основных состояния: **Ожидание(Pending)**, **Успешно завершен(Resolve)**, **Завершен с ошибкой(Reject)**. Для работы с ним нужно создать функцию, зарегистрировать в ней resolve и reject, указать асинхронный код в теле функции. Когда асинхронная операция завершится, нужно вызвать resolve или reject в зависимости успешна ли она или неудачна. После можно обработать результат при помощи .then, если всё успешно или при помощи .catch, если результат неудачный. ***Способ обработки асинхронного кода***, помимо Promise: 1. **Async/await** - Async обозначает, что функция будет работать с асинхронным кодом и будет возвращать Promise, а await указывается внутри этой функции и заставляет код ждать до тех пор, пока Promise с await не выполнится. 2. **Callback** - передача функции, как аргумент, которая будет вызвана после асинхронной операции. 3. Еще можно использовать **Observable**, но это уже класс из библиотеки RxJs, который в основном используется в Angular. 2)  ***Event Loop*** настолько важен в асинхронности, что без него не получилось бы реализовать асинхронность. Так как весь код выполнялся бы синхронно, потому что JavaScript однопоточный и Event Loop как раз таки помогает перемещать функции в потоке. Если формулировать термином, то Event Loop - механизм обработки асинхронных событий. В нем есть два события Call Stack(стек вызовов) и Event Queue (очередь событий). Сами функции делятся на Micro и Macro, что влияет на их очередность в очереди событии. Благодаря этому JavaScript может обрабатывать таймеры, промисы, события и сетевые запросы без блокировки основного потока. Таким образом, Event Loop является основой всей асинхронной модели JavaScript.
3) ***ООП*** - это Объектно-Ориентированное Программирование, где основой являются объекты, объединяющие в себе свойства и методы. Это принцип программирования, свод правил, которые определяют стиль написания программы. Помимо ООП стиля, существует функциональный и другие. Основные принципы **ООП**: **Инкапсуляция** - Объект хранит в себе данные и методы, и мы ограничиваем доступ к внутренней реализации. Снаружи можно пользоваться только тем интерфейсом, который мы явно предоставили. Например:   
```
class User {
#password; 

constructor(name, password) {
this.name = name;
this.#password = password;
}

checkPassword(pass) {
return this.#password === pass;
}
}

const u = new User("Victor", "1234");
console.log(u.name);         // Victor - true
console.log(u.#password);    // Это выдаст ошибку
```
Пароль находится в приватном свойстве (#password). Поэтому другие части кода не могут напрямую достать пароль из объекта, а только вызвать метод checkPassword(). Таким образом, мы прячем детали и защищаем данные.  
**Наследование** - создание новых классов и объектов на основе существующих, расширяя их функционал. Например:
```
class User {
  constructor(name) {
    this.name = name;
  }
}

class Admin extends User {
  constructor(name, role) {
    super(name); 
    this.role = role;
  }
}
```
Тем самым у нас появилось новое свойство (role).
***Полиморфизм*** - Один и тот же метод может работать по-разному для разных объектов. Например:
```
class User {
  constructor(name) {
    this.name = name;
  }
}

class UserOne extends User {}
class UserTwo extends User {}

const users = [
  new User("Виктор"),
  new UserOne("Анатолий"),
  new UserTwo("Богдан")
];

users.forEach(u => console.log(`Меня зовут ${u.name}`));
```
***Абстракция*** - выделение сущностей и их интерфейсов, избавление от лишних деталей, то есть вся реализация оставлена наследникам. Например:
```
class User {
  constructor(name) {
    this.name = name;
  }

  greet() {
    throw new Error("Метод greet() должен быть реализован в подклассе");
  }
}

class UserOne extends User {
  greet() {
    console.log(`Привет, я UserOne и меня зовут ${this.name}`);
  }
}

class UserTwo extends User {
  greet() {
    console.log(`Привет, я UserTwo и меня зовут ${this.name}`);
  }
}

const users = [
  new UserOne("Виктор"),
  new UserOne("Анатолий"),
  new UserTwo("Богдан")
];

users.forEach(user => user.greet());

```
В JavaScript объектно-ориентированное программирование реализовано через объекты и прототипы. Каждая функция в JS может выступать как конструктор объектов, а объекты наследуют свойства и методы через прототипную цепочку. С ES6 появились классы (class), которые предоставляют синтаксический сахар для создания конструкторов и наследования, но под капотом всё равно используется прототипное наследование. Объекты могут содержать свойства и методы, а классы поддерживают наследование (extends), инкапсуляцию (private, #) и статические методы. Методы можно вызывать через объекты, а ключевое слово this внутри метода ссылается на конкретный объект. Таким образом, JS сочетает гибкость прототипов с синтаксисом классов для ООП.

4) Начинается процесс с ввода пользователем URL, после отправки, браузер запрашивает у DNS сервера IP адрес. Следующим шагом браузер соединяется с сервером через HTTPs запросы GET/POST с заголовками Accept, User-Agent, Cookies и так далее. (Раньше подключения были через HTTP, но они были уязвимы, так как не было шифрования. В HTTPs же шифруются данные при помощи TLS/SSL). После приходит ответ сервера, если он удачный, например 200, то документ с HTML/CSS/JS и начинается построение страницы. Начиная с HTML, CSS, и заканчивая JS. Браузер считывает данные пользователя, такие как размер экрана и т.д и под них уже выстраивает документ. Заканчивается все событием **DOMContentLoaded** Загрузку можно ускорить благодаря **кэшированию**. Браузер может сохранять уже открытые сайты, благодаря памяти в кэше, что ускоряет загрузку. Так же можно использовать отложенную загрузку (**lazy-loading**), разбивать проект на модули, чтобы не весь проект сразу грузился, а только модуль, на котором находится пользователь. SSR - рендеринг на стороне сервера так же ускоряет визуальную загрузку. **Возможные проблемы с безопасностью**: **CORS** — браузер по умолчанию запрещает чтение ответов с другого сервера, если сервер явно не разрешил (Access-Control-Allow-Origin). **XSS** - вставка вредоносного скрипта, зачастую используется при innerHtml, поэтому его не рекомендуется использовать. В ***Angular*** встроен механизм, который экранирует HTML и спецсимволы, тем самым защищает от XSS, чтобы выключить механизм, нужно использовать **DomSanitizer.bypassSecurityTrustHtml()**. Также проблемы могут вызывать просроченные сертификаты безопасности **TLS**, они могут блокировать соединение. Думаю, существуют и другие методы, но это всё, что я пока что знаю. 
